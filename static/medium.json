{
  "author": "Disassemble IO",
  "stories": [
    {
      "title": "javanalysis",
      "link": "https://medium.com/@disassemble.io/javanalysis-4278d78c729c?source=rss-717bf4aafbfa------2",
      "categories": [
        "programming",
        "java",
        "repositories",
        "bytecode"
      ],
      "published": "Sun, 21 May 2017 11:57:53 GMT",
      "updated": "2017-05-21T20:53:34.680Z",
      "content": "<p>OW2’s library for java bytecode, <a href=\"http://asm.ow2.org/\">ASM</a>, is a very useful and powerful tool. But many overlook the power that <a href=\"http://jboss-javassist.github.io/javassist/\">javassist</a> can provide. I think that the main reason is simply because it lacks the analysis features that ASM includes.</p><p>Another reason that javassist might not be as widely used is because it lacks the OOP structure behind instructions, instead only providing the <a href=\"https://jboss-javassist.github.io/javassist/html/javassist/bytecode/ConstPool.html\">ConstPool</a> and access to each instruction’s index and opcode. This makes it a much more difficult task than it needs to be to even look up something as simple as getting a GETFIELD’s field name.</p><p>Why should one have to iterate through a byte[] array of indices, and use:</p><pre>ConstPool pool = method.pool();<br>CodeAttribute attr = method.code();<br>CodeIterator itr = attr.iterator();<br>..<br>int index = itr.next();<br>int poolIndex = itr.u16bitAt(index);<br>String name = pool.getFieldrefName(poolIndex);</pre><p>to retrieve that name, instead of having some structured code that enables one to do that in a much cleaner way?</p><pre>method.instructions().forEach(insn -&gt; {<br>    if (insn instanceof FieldInsn) {<br>        String name = ((FieldInsn) insn).name();<br>    }<br>});</pre><p>The current library that I’m working on allows for just that: <a href=\"https://github.com/disassemble-io/javanalysis\">javanalysis</a></p><p>The goal of the project is to structure javassist in such a way that it can be just as useful, if not more, than ASM. With the support that javassist has — being backed by JBoss/RedHat and having some features of Java 9 already supported— I feel this is a positive direction to go.</p><p>It is feature packed, including a ControlFlowGraph, and other features.</p><p>As an example of what javanalysis can do when wrapped around javassist’s CFG, all data in the image below is accessible through OOP structures.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/574/1*N0-_rW7y-sI2OzlD5LnZQA.png\" /></figure><p><strong>TL;DR</strong>: A project, <a href=\"https://github.com/disassemble-io/javanalysis\">javanalysis</a>, is in active development with a goal to be as functional as ASM, while using javassist as a backend.</p><p><em>Written by Tyler Sedlar</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4278d78c729c\" width=\"1\" height=\"1\">"
    }
  ]
}